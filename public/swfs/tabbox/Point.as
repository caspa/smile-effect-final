class Point {	/*	Point object	--------------		============	*/	var x:Number;	var y:Number;	function Point(x, y) {		this.x = x;		this.y = y;	}	//(returns a formatted string containing x,y)	function ToString() {		return ("("+this.x+","+this.y+")");	}	function dist(v2:Point) {		return Math.sqrt(Math.pow(this.len(), 2)+Math.pow(v2.len(), 2));	}	//----- these functions return Points -----	//return a copy of this	function clone() {		var v = new Point(this.x, this.y);		return v;	}	//return this+v2	function plus(v2) {		var v = new Point(this.x+v2.x, this.y+v2.y);		return v;	}	//return this-v2	function minus(v2) {		var v = new Point(this.x-v2.x, this.y-v2.y);		return v;	}	//return the righthand normal of this (using flash's coordinate system)	function normR() {		var v = new Point(this.y*-1, this.x);		return v;	}	//return the (unit) direction vector of this	function dir() {		var v = this.clone();		v.normalize();		return v;	}	//return this projected _onto_ v2	function proj(v2) {		var den = v2.dot(v2);		if (den == 0) {			//zero-length v2			trace("WARNING! Point.proj() was given a zero-length projection vector!");			var v = this.clone();//not sure how to gracefully recover but, hopefully this will be okay		} else {			var v = v2.clone();			v.mult(this.dot(v2)/den);		}		return v;	}	//return the magnitude (absval) of this projected onto v2	function projLen(v2) {		var den = v2.dot(v2);		if (den == 0) {			//zero-length v2			trace("WARNING! Point.projLen() was given a zero-length projection vector!");			return 0;		} else {			return Math.abs(this.dot(v2)/den);		}	}	//----- these functions return scalars -----	//return the dotprod of this and v2	function dot(v2) {		return ((this.x*v2.x)+(this.y*v2.y));	}	//return the crossprod of this and v2	//note that this is equivalent to the dotprod of this and the lefthand normal of v2	function cross(v2) {		return ((this.x*v2.y)-(this.y*v2.x));	}	///return the length of this	function len() {		return (Math.sqrt((this.x*this.x)+(this.y*this.y)));	}	//----- these functions return nothing (they operate on this) -----	//change this to a duplicate of v2	function copy(v2) {		this.x = v2.x;		this.y = v2.y;	}	//multiply this by a scalar s	function mult(s) {		this.x *= s;		this.y *= s;	}	//convert this vector to a unit/direction vector	function normalize() {		var L = this.len();		if (L != 0) {			this.x /= L;			this.y /= L;		} else {			trace("WARNING! Point.normalize() was called on a zero-length vector!");		}	}	//add v2 to this	function pluseq(v2) {		this.x += v2.x;		this.y += v2.y;	}	//subtract v2 from this	function minuseq(v2) {		this.x -= v2.x;		this.y -= v2.y;	}}